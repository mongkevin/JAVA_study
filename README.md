# JAVA_Study
Study JAVA basic elements
자바를 시작하며 공부한 내용들이다. 기초를 14개 프로젝트로 정리하였다.


---
## 01_My_First_Project

### Method : 쉽게 이해하기 위해 기능을 의미한다.  
하나의 클래스에 여러개의 메소드가 존재 가능하다.  
메소드의 이름은 중복이 가능하지만 특정 조건을 만족하여야한다.

메소드는 main 메소드와 일반 메소드로 나눤다.  
메소드는 실행하는 것을 호출한다.   
일반 메소드 같은 경우에는 스스로 실행될 수 없다.  
다른 메소드에서 호출을 해줘야만 실행될 수 있다.  

---
## 02_Variable  

### 형변환: 값의 종류라는 뜻, 캐스트한다라는 것은 자료형을 바꾸는 개념이다

### 컴퓨터에서 값을 처리하는 규칙   
1. = (대입연산자)를 기준으로 양쪽이 같은 자료형이여야 한다.  
자료형이 다를경우 오른쪽 대입할 자료형을 변경시켜야한다.  
2. 같은 자료형끼리만 연산이 가능하다.  
-다른 자료형끼리 연산을 하고자 한다면 둘중 하나는 형변환을 통해 동일한 자료형으로 변환해야한다.  
3. 연산의 결과물도 같은 자료형이여야 한다.  

[표현법](바꿀자료형)값
형변환연산자,cast 연산자

### 형변환의 종류  
1. 자동형변환 : 자동으로 형변환된다. 직접 형변환 해줄 필요 없다.  
작은 크기의 자료형 -> 큰 크기의 자료형  
2. 강제형변환 : 자동으로 형변환이 진행되지 않는 경우.  
직접 형변환을 해야한다->형변환 연산자를 통해 
큰 크기의 자료형 -> 작은 크기의 자료형  
때문에 값의 손상이 있을 수 있다.  

### 구문 출력방법
System.out.printf("출력하고자 하는 형식", 출력하고자하는 값);  
여기서 f는 format(형식)을 의미한다.  
단, 문자열안에 원하는 값이 들어갈 공간을 형식화 하여야한다.  

형식  
* %d : 정수  
* %f : 실수  
* %c : 문자  
* %s : 문자  

```java
System.out.printf("Hello World");
//printf로 출력 - 줄바꿈 기능이 없기 때문에 개행문자 \ n으로 줄 바꿈 해준다.
System.out.println("Hello World");
```

etc)
키보드로 사용자로부터 값을 입력받으려면?  
자바에서 제공하고 있는 java.util.Scanner 라고하는 클래스를 활용하면 된다.  

```java
import java.util.Scanner;
Scanner sc = new Scanner(System.in);
```

---
## 03_Operator

### 산술 연산자: 이항연산자로서 연산방법, 우순위가 일반 수학산과 동일하다.
* 덧셈: +, 뺄셈: -, 곱셈: *, 나눗셈: /, 나머지(Modular): % (나눗셈에서 나머지를 구한다.)  

### 증감연산자: 당항 연산자로서 한 번에 1씩 증가 하거ㅓ나 1씩 감소하는 연산을 말한다.  
* -먼저 증감을 할 것인지 나중에 증감을 할것인지 연산자의 위치에 따라 달라진다.  
* [표현법]  
* ++ : 값을 1씩 증가시키는 연산자  
* -- : 값을 1씩 감소시키는 연산자  

### 연산자의 위치
* 전위연산: ++값, --값 (먼저 1을 증감처리한 후 그 값을 처리한다)
* 후위연산: 값++, 값-- (값을 먼저 처리한 후에 증감을 수행한다)

### 복합대입연산자: 다른 산술 연산자랑 대입연산자가 결합한 것. 이항연산자
* -자기 자신과 해당 산술연산 후에 그 결과를 다시 자신에게 대입하는 연산자. 
* +=  
* -=  
* *=  
* \       /=  
* %=    
예시) a += 3; 은 a = a + 3; 기존에 a라는 값에 +3을 한 뒤에 다시 a에 대입해라.

### 논리 부정 연산자 : 논리값(true/false)를 반대로 바꿔주는 연산자  
[표현법]!논리값
```java
if(!flase){
  System.out.print("Hello World");
}
```

### 비교연산자 (관계연산자)
* 두개의 값을 가지고 비교, 이항 연산자
* 비교연산을 한 결과 -> 참일 경우 ture / 거짓일 경우 false
* 특정 조건을 제시할 수 있는 조건문에서 쓰인

종류  
1. 크고 작음을 비교
* a < b : a가 b보다 작습니까?
* a > b : a가 b보다 큽니까?
* a <= b : a가 b보다 작거나 같습니까?
* a >= b : a가 b보다 크거나 같습니까?
2. 일치함을 비교 - 동등비교
* a == b : a와 b가 같습니까?
* a != b : a와 b가 같지 않습니까?
* 피연산자는 숫자, 결과값은 논리값

### 논리 연산자 : 이항연산자, 두개의 논리값을 연산하는 연산자.
* [표현법] 논리값 논리연산자 논리값 -> 결과값도 논리값  

종류
1. AND 연산자: 논리값 && 논리값 [왼쪽, 오른쪽 둘다 	true여야 결과값도 true]  
2. or 연산자: 논리값 || 논리값 [왼쪽, 오른쪽 둘 중 하나라도 true면 결과값이 true]

### 삼항 연산자 : 피연산자가 3개 -> 값 3개와 연산자 1개로 이루어짐.
조건식 형태로 쓰인다.  

 #조건식 :  결과값에 따라서 연산을 처리하는 방식
* 결과값이 참일 경우 식1을 처리하고.
* 결과값이 거짓일 경우 식2를 처리한다.
[표현법]
조건이 ? 조건이 true일 경우 결과값: 조건이 false일 경우 결과값;
```java
Scanner sc = new Scanner(System.in);
System.out.println("정수 입력 : ");
int num = sc.nextInt();
//중첩삼항연산자를 이용하여.		
String result = (num != 0) ? ((num >0)? "양수입니다." : "음수입니다.") : "0입니다.";
System.out.println("입력 받은 " + num + "은 " + result);
```
  
---
## 04_Control

### 단독 if
[표현법]
```java
if(조건식){
  //수행하고자 하는 구문
}
```
* -조건식의 결과값이 true일 경우: 중괄호 안에 있는 코드를 실행
* -조건식의 결과값이 false일 경우: 중괄호 안에 있는 코드를 건너 뜀

### if-else 문 
[표현법]
```java
if(조건식){
  // 조건식이 만족할때(true) 실행하고자 하는 구문 - 1번 
}else{
  // 조건식이 만족하지 않을때 (false) 실행하고자하는 구문 - 2번 
}
```
* -조건식의 결과가 true일 경우엔 1번 코드만 실행
* -조건식의 결과가 false일 경우엔 2번 코드만 실행

### switch 문
[표현법]
```java
switch(아래에 기술할 값들과 동등비교를 할 대상){
  case 값1 : 실행할 코드; // - 대상자 == 값1이 true일 경우 실행할 코드
  break; - switch // 영역을 벗어난다.
case 값2 : 실행할 코드; // - 대상자 == 값2이 true일 경우 실행할 코드
  break; // - switch 영역을 벗어난다.
   //...
case 값n :실행할 코드; // - 대상자 == 값n이 true일 경우 실행할 코드
  break; // - switch 영역을 벗어난다.

default : 실행할 코드; // -if-else문에서 else와 같은 역할을 수행한다.
  //위에 case들을 모두 만족하지 않으면 실행할 코드를 작성한다.
  //break를 적지 않는다(마지막에 실행되고 switch문을 벗어나기 때문)
  //또한 생략이 가능하다.
}
```
**반복문 안에서 쓰이는 구문**   
1. break; :break문을 만나는 순간 "가장 가까운 반복문"을 벗어난다.
* 해당 break; 문을 포함한 가장 가까운 반복문 한겹만 벗어난다.  
* 주의할 점: switch문 안에 있는 break와는 다른 역할.  
* switch문 안에 있는 break는 해당 switch문을 벗어하는 용도로 사용된다. (반복문에 영향 X)
```java
Scanner sc = new Scanner(System.in);
		
while(true){ //무한반복		
  System.out.println("숫자를 입력해주세요.");
  int num = sc.nextInt();
  if(num >= 0) {
    System.out.println(num);
  }else { //입력 받은 수가 음수라면 -- 무한반복을 벗어날 조건
    System.out.println("프로그램을 종료합니다.");
    break;
  }
}
```
2. continue; 구문을 만나면 뒤에 있는 코드를 실행하지 않고 다시 반복문을 실해하게 된다.  
* 이때 for문의 경우는 증감식으로 이동.  
* while문의 경우는 조건식으로 흐름이 이동된다.  
```java
Random r = new Random();
for(int i = 1; i <= 10; i = i+1) {
  int random = r.nextInt(10) + 1;//1부터 10개까지 
  //홀수인 경우니깐 작수인 경우를 제외시키면 된다.
  if(random % 2 == 0) { //random 값을 나누기 2한 나머지 값이 0이라면 짝수라고 볼 수 있다.
  	continue;
	}
  System.out.println(random + "홀수가 나왔넹.");
}
```

*-switch문과 if문의 차이점*   
*-if(조건식) -> 조건식에 범위 설정이 가능하다.*  
*-switch(대상자) -> 범위설정 불가 식이 있더라도 값이 정해지는 식이여야한다.(동등비교)*  

### for문
괄호 안의 반복을 지정하고 부분이 있고, 초기식, 조건식, 증감식 세가지로 이루어진다.  
각각 세미콜론으로 구분되며 증감식에는 세미콜론을 붙이지 않는다.  
[표현법]
```java
for(최기식; 조건식; 증감식){
  // 반복시키고자 하는 내용
}
```
-초기식: 반복문이 시작될때 "최기에 단 한번만 실행" 될 구문  
* 		즉, 반복문에서 사용할 변수를 선언하고 초기화하는 구문이다. ex) int i = 0;
-조건식: "반복문이 실행될 조건"을 작성하는 구문  
* 		조건식이 true일 경우 반복문 실행 false일 경우 반복문을 멈추고 빠져나온다
* 		보통 초기식에서 선언된 변수를 가지고 조건식을 작성한다. ex) i<10;
-증감식: 반복문을 제어하는 변수 값을 증감시키는 구문  
* 		보통 초기식에서 선언된 변수를 가지고 증감식을 작성한다.
* 		이때 증감연산자가 주로 사용된다. ex) i++

*for문을 만나는 순간*  
초기식 ->조건식(조건검사) ->true일 경우 실행 ->증감식  
 		->조건식 (조건검사) ->true일 경우 실행 ->증감식  
 		->......    
 		->조건식(조건검사 ->false일 경우 코드를 실행하지 않고 반복문을 벗어난다.  
**조건식이 true일 경우에만 코드를 실행한다.**  

### While문
괄호 안에 조건이 true인 경우 해당 구문을 반복적으로 실행
조건식에 true를 작성하면 무한반복
[표현법]
```java
// 초기식; --생략가능
while(조건식){
  // 반복시키고자 하는 구문
  // 증감식; --생략가능
}
```
**조건식이 true이면 내부 코드를 실행 false라면 실행하지 않음**

### do - while
별도의 조건검사 없이 무조건 최초 1회는 실행하는 구문.
조건이 맞지 않아도 1번은 실행된다.
[표현법]
```java
// 초기식--생략가능
do{
  // 실행할 코드	
  // 증감식 --생략가능
}while(조건식);
```
**while문과 do-while문의 차이점** 
* while문은 조건식이 거짓일 경우 실행되지 않지만 do-while문은 조건식이 거짓이여도 최초 1번은 실행된다.

---
## 05_Array

1. 변수: 하나의 공간에 하나의 값만 담을 수 있다.  
2. 배열: 하나의 공간에 여러개의 값을 담을 수 있다.  
  **단," 같은 자료형일때만"**
![image.png](./image/image.png)  

* 배열의 각각 인덱스자리에 실제 값이 담기는 형태 / 만약 참조형 배열이면 실제값이 아닌 주소값이 담긴다.  
* 변수를 이어붙여 하나의 이름으로 다루는 방식  

*배열의 선언* 
[표현법] - 두가지 방식  
1) 자료형[ ] 배열명;  (가장 흔하게 쓰이는 방식이기도 하다)  
2) 자료형 배열명[ ];  
```java
int a; //int자료형 변수 선언
int[] arr; //int[]자료형 배열 선언(int형 배열)
int arr2[]; //배열 선언 2번째 방식
```
*배열의 할당*  
* 해당 배열에 몇개의 값이 들어갈지 배열의 크기를 지정하는 과정.  
* 지정한 크기만큼의 공간이 생성된다.  
[표현법]
```java
  int[] arr = new int[5];
  //arr이라고하는 배열변수에 int자료형 배열 5칸짜리를 만들어서 주소값을 넣어준다.
```
**배열의 큰 단점: 크기를 변경할 수 없다.**   
그렇게 때문에 새로운 배열을 생성하여 할당 받아야한다.  
이때 기존의 배열 변수를 활용하고자 한다면 재할당을 받아주면 된다.   
ex) int[] arr = new int[3]; -> arr = new int[5];  
배열은 항상 고유한 주소값이 부여된다. 기존에 생성된 배열과 겹치지 않음(중복x)  
그래서 새로운 배열의 크기를 할당받고자 한다면 새 주소를 받아 할당받는 것.  
이렇게 새롭게 할당받은 주소를 갖게된 배열변수로 변경된 크기의 배열을 다루게 된다.  
기존에 다뤄졌던 배열은 더 이상 참조당하는 곳이 없기 때문에  
GC (garbage collector)가 처리해준다. (자동 메모리 관리)  

**배열의 복사**  
* 얕은 복사 - 주소값 복사
* 깊은 복사 - 실제 데이터 복사

1. System.arraycopy 메소드
몇번 인덱스부터 몇개를 어느 위치에 복사할 것인지 지정가능하다.
```java
System.arraycopy(원본배열이름, 원본배열에서 복사시작할 인덱스, 
      						복사본배열이름, 복사본배열에서 복사될 시작인덱스, 복사할 개수)
```
2. Arrays.copyOf() 메소드 (Arrays 클래스에서 제공하는 copyOf() 메소드)
원본배열의 0번인덱스부터 시작하여 복사가 진행되고 내가 제시한 개수 만큼 복사된다.  
만약 내가 제시한 개수가 원본배열의 크기보다 크다면 나머지 공간은 0으로 초기화된채로 생성된다.(크기지정)
```java
// 복사본 배열=Arrays.copyOf(원본배열이름, 복사할 개수);
int[] copy = Arrays.copyOf(origin, 10);
```
3. 원본배열.clone(); 메소드
원본배열과 동일하게 복사한다.(크기, 인덱스지정하지 않음)
```java
// 복사본배열 이름= 원본배열이름.clone();
// 원본배열.clone(); - 시작인덱스, 개수 지정하지 않음 -> 원본이랑 똑같이 만들기
int[] copy = origin.clone();
```

---
## 06_Object

---
## 07_ObjectArray

---
## 08_Inheritance

---
## 09_Polymorphism

---
## 10_API

---
## 11_Exception

---
## 12_IO

---
## 13_Collection

---
## 14_Network


<hr>
**14_Network
